Hello World想必大家应该都用某种语言写过。我们就从这个与之类似的简单程序开始：写一个输出日志的函数来方便调试。比如这里是一个用 Ruby 写成的例子：

    def log_the_shit(shit)
      STDERR.puts(shit)
    end

    # Usage:
    log_the_shit('meh')

其中STDERR是程序的标准错误输出流，这个函数已经能够正常地工作，逻辑上也没什么大问题 - 毕竟只是简单地把参数转发至 Ruby 标准库[1]内置的函数而已。只要没有哪个菜鸟手贱覆写掉STDERR常量[2]，all is well。但是很明显如此简单的逻辑是满足不了残酷变化的需求的：和你一起奋战的同事/同学是个调试癖，这丫喜欢使用这个函数大量输出调试信息，而你自己只是在程序出错的时候稍微用一用来完成调试任务而已，用完立即删除，绝不提交进版本控制。当你正为一个焦头烂额地调试的时候，绝大多数日志信息都来自你的同事，对你来说与噪音无异。

怎么解决这问题？上上上次面试积累的教训是“团队协作最重要的是沟通”。于是你在午饭的时候跟这位同事以不太严肃的态度开始聊起来：

    - “我说那个谁啊，我发现你打印的日志好像有点多？”
    - “废话，不打日志怎么调试？反正临发布前再用个sed脚本清理一下就差不多了”

听到“废话两个字”你就知道接下来对话没法轻松友好地继续了。这王八蛋不仅表明了“少跟老子讲理”的态度，还给出了个似乎合理的解决方案用来炫耀他的sed知识 - 当然对你来说根本没解决问题。

事已至此，修改 log_the_shit 函数似乎是唯一的出路。但是你肯定不希望破坏它原有的行为，否则别人的代码都将被迫改动。还好 Ruby 支持可变参数与默认参数：

    def log_the_shit(shit, output_stream=STDERR)
      output_stream.puts(shit)
    end

    # Usage:
    my_own_log_file = File.open '/tmp/debugging_shit'
    log_the_shit('there it goes', my_own_log_file)

恭喜，你已经完成了一次成功的API演进。不仅良好地保证了向后兼容，还满足了你需要的行为扩展。

### 总结：参数化

* 函数或方法是绝大多数编程语言都支持的抽象机制
* 把可能变动的东西参数化就可以应对行为变动
* 尽力维护向后兼容，尤其在同事脾气不好的情况下
* 默认(缺省？)参数可以用来提供合理的默认值，同时也是维护函数向后兼容的手段之一

慢慢来，今天先到这。

注：
[1] 严格来说这部分属于 Ruby core library 而不是 standard library。前者不需要require即可直接使用，后者虽然与ruby一起发布但需要require相应的文件加载。 可参考 [www.ruby-doc.org](http://www.ruby-doc.org) 的划分
[2] Ruby里常量可以被重新赋值，虽然会给出警告。不过程序员普遍会无视警告。
